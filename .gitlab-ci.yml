# You can override the included template(s) by including variable overrides
# SAST customization: https://docs.gitlab.com/ee/user/application_security/sast/#customizing-the-sast-settings
# Secret Detection customization: https://docs.gitlab.com/ee/user/application_security/secret_detection/pipeline/#customization
# Dependency Scanning customization: https://docs.gitlab.com/ee/user/application_security/dependency_scanning/#customizing-the-dependency-scanning-settings
# Container Scanning customization: https://docs.gitlab.com/ee/user/application_security/container_scanning/#customizing-the-container-scanning-settings
# Note that environment variables can be set in several places
# See https://docs.gitlab.com/ee/ci/variables/#cicd-variable-precedence
stages:
  - build
  - test
  - code-style
  - release
sast:
  stage: test
include:
  - template: Security/SAST.gitlab-ci.yml

build:vendors:
  stage: build
  artifacts:
    untracked: true
  only:
    refs:
      - merge_requests
      - push
  cache:
    key:
      files:
        - composer.lock
    policy: pull-push
  image: composer:2
  script:
    - composer install --no-interaction --prefer-dist --optimize-autoloader

tests:
  stage: test
  dependencies:
    - build:vendors
  only:
    refs:
      - merge_requests
      - push
  cache:
    key:
      files:
        - composer.lock
    policy: pull
  image: php:8.2
  before_script:
    - apt-get update -yqq
    - apt-get install -yqq libpng-dev libjpeg-dev libfreetype6-dev libwebp-dev
    - apt-get install -yqq libsqlite3-dev
    - docker-php-ext-configure gd --with-freetype --with-jpeg --with-webp
    - docker-php-ext-install gd pdo_sqlite
  script:
    - ./vendor/bin/pest --ci

code-style:
  stage: code-style
  dependencies:
    - build:vendors
  only:
    refs:
      - merge_requests
      - push
  cache:
    key:
      files:
        - composer.lock
    policy: pull
  image: php:8.2
  allow_failure: true
  script:
    - ./vendor/bin/phpcs --standard=ArtisanPackUIStandard src

# Job 1: Prepare the release description from CHANGELOG.md
prepare_release_description:
  stage: release
  image: alpine:latest # Use alpine for grep, sed, and bash
  before_script:
    # Install necessary tools: grep, sed, and bash
    - apk add --no-cache grep sed bash
  rules:
    - if: $CI_COMMIT_TAG # This job will only run when a Git tag is pushed
  script:
    - |
      set -euxo pipefail # Enable debugging flags for debugging

      echo "--- Preparing Release Description ---"
      echo "CI_COMMIT_TAG: ${CI_COMMIT_TAG}"

      # Verify CHANGELOG.md exists in the current working directory
      echo "Listing files in current directory ($(pwd)):"
      ls -la
      if [ ! -f "CHANGELOG.md" ]; then
        echo "Error: CHANGELOG.md not found in the repository root. Cannot extract release description."
        # Provide a default description if CHANGELOG.md is missing.
        # This will be passed to the next job.
        RELEASE_DESCRIPTION_FINAL="Release ${CI_COMMIT_TAG}. No CHANGELOG.md found. Please create one."
      else
        echo "CHANGELOG.md found. Attempting to read content."
        echo "--- Start of CHANGELOG.md Content ---"
        cat CHANGELOG.md
        echo "--- End of CHANGELOG.md Content ---"

        # Extract the version number from the Git tag (e.g., 'v1.2.3' -> '1.2.3')
        RELEASE_VERSION=$(echo "${CI_COMMIT_TAG}" | sed 's/^v//')
        echo "Extracted RELEASE_VERSION: ${RELEASE_VERSION}"

        # Define markers for the start and end of the desired section in CHANGELOG.md
        # Assumes CHANGELOG.md headings are like '## [X.Y.Z]'
        START_MARKER="## \\[${RELEASE_VERSION}\\].*"
        END_MARKER="## \\[[^]]*\\].*" # Matches the next version heading
        echo "START_MARKER: ${START_MARKER}"
        echo "END_MARKER: ${END_MARKER}"

        # Extract the block of text for the current release from CHANGELOG.md
        CHANGELOG_CONTENT=$(sed -n "/${START_MARKER}/,/${END_MARKER}/p" CHANGELOG.md)
        echo "Raw CHANGELOG_CONTENT extracted (may be empty if no match):"
        echo "${CHANGELOG_CONTENT}"

        # Clean up the extracted content:
        # Check if CHANGELOG_CONTENT is empty before piping to grep/sed to avoid errors
        if [ -z "${CHANGELOG_CONTENT}" ]; then
          TEMP_DESCRIPTION="" # Set to empty if no content extracted
        else
          TEMP_DESCRIPTION=$(echo "${CHANGELOG_CONTENT}" | \
            grep -v "${START_MARKER}" | \
            grep -v "${END_MARKER}" | \
            grep -v "^# Changelog" | \
            sed -e 's/^[[:space:]]*//' -e '/^$/d')
        fi

        # Fallback description if the specific version isn't found or extraction failed
        if [ -z "${TEMP_DESCRIPTION}" ] || [ "${TEMP_DESCRIPTION}" = " " ]; then
          echo "Warning: Could not find a specific description for tag ${CI_COMMIT_TAG} in CHANGELOG.md or extracted content was empty/whitespace. Using a generic description."
          RELEASE_DESCRIPTION_FINAL="Release ${CI_COMMIT_TAG}. Refer to CHANGELOG.md for detailed changes."
        else
          RELEASE_DESCRIPTION_FINAL="${TEMP_DESCRIPTION}"
        fi
      fi

      echo "--- Final Release Description Content to be Passed ---"
      echo "${RELEASE_DESCRIPTION_FINAL}"
      echo "----------------------------------------------------"

      # Escape newlines in RELEASE_DESCRIPTION_FINAL for the .env file
      # The sed command will convert all newlines into literal '\n' sequences.
      ESCAPED_RELEASE_DESCRIPTION=$(echo "${RELEASE_DESCRIPTION_FINAL}" | sed -E ':a;N;s/\n/\\n/g;ta')

      # Save the final escaped description to a .env file.
      # This file will be picked up by the next job due to 'artifacts:reports:dotenv'.
      echo "RELEASE_DESCRIPTION=${ESCAPED_RELEASE_DESCRIPTION}" > release.env
      echo "Description saved to release.env"
  artifacts:
    reports:
      dotenv: release.env # Export variables from release.env to subsequent jobs

# Job 2: Create the GitLab Release using the extracted description
create_actual_release:
  stage: release
  image: registry.gitlab.com/gitlab-org/release-cli:latest # Use the official release-cli image
  needs:
    # Ensure this job runs after 'prepare_release_description' and inherits its dotenv artifacts.
    - job: prepare_release_description
      artifacts: true
  rules:
    - if: $CI_COMMIT_TAG # Only run this job if a tag is pushed
  script:
    # Use the literal block scalar for the entire script to avoid YAML parsing issues.
    - |
      set -euxo pipefail # Enable debugging flags for debugging
      echo "--- Creating GitLab Release ---"
      echo "CI_COMMIT_TAG: ${CI_COMMIT_TAG}"
      # The RELEASE_DESCRIPTION variable is automatically loaded from the dotenv artifact of the previous job.
      echo "Received RELEASE_DESCRIPTION: ${RELEASE_DESCRIPTION}"
      # Create the release using release-cli
      release-cli create --name "Release ${CI_COMMIT_TAG}" --tag-name "${CI_COMMIT_TAG}" --description "${RELEASE_DESCRIPTION}"
      echo "Release created successfully."
